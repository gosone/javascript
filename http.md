## HTTP请求头
1. Accept：可接受的响应内容类型
2. Accept-encoding：可接受的编码类型
3. cookie
4. referer
5. host
6. canche-control
7. user-agent
8. range

## HTTP响应头
1. Access-Control-Allow-Origin
2. Allow
3. Expires
4. set-cookie
5. Etag
6. last-Modified
7. Server

## HTTP2
1. 多路复用：可以在一个tcp连接上发送多个请求，在一个tcp连接上有多个流，将要传输的数据分成多个二进制的帧单元，进行标记，还可以设置优先级，服务器端收到后将帧进行组合。
2. 二进制协议：
3. 头部压缩：使用HPACK规范作为一个简单又安全的方法来实现请求头压缩，客户端和服务端维护一个请求头列表。HPACK会在每个请求头发给服务器之前对其单独的值进行压缩，具体实现方法就是：在之前发送过的请求头列表中查找已编码的请求头信息，来重新组成整个请求头信息。
4. 服务器推送：允许服务器发送额外的信息给客户端，这些额外的信息客户端并没有请求但接下来很可能会用到。例如，如果客户端请求了资源X，而Y资源接下来很明显也会请求，服务器就可以选择把Y资源和X资源一起发给客户端，而不需等到客户端请求在发送。

## HTTP1.1
建立了长连接，但是可能会因为某个请求丢失等问题，出现队头阻塞的问题
新增了OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT

## HTTPS
1. 客户端向服务端发送建立连接的请求
2. 服务端保存着一个公钥和一个私钥，向客户端发送ca证书，包括有效期等，还有公钥
3. 客户端收到ca证书后，向机构请求，验证ca证书的合法性，如果合法的话，就生成一个随机数，作为客户端密钥，通过公钥加密后发送给服务端
4. 服务端收到后，用私钥解密，得到客户端密钥，将数据用客户端密钥加密后发送给客户端。

## HTTP请求
1. GET	请求指定的页面信息，并返回实体主体。
2. HEAD	类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
3. POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
以下为http1.1新增
4. PUT	从客户端向服务器传送的数据取代指定的文档的内容。
5. DELETE	请求服务器删除指定的页面。
6. CONNECT	HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
7. OPTIONS	允许客户端查看服务器的性能。
8. TRACE	回显服务器收到的请求，主要用于测试或诊断。
9. PATCH	是对 PUT 方法的补充，用来对已知资源进行局部更新。

### Get

* GET请求的数据会附加在URL之后，用问号分割，多个参数用&进行连接。
* GET请求的数据会暴露在地址栏中。
* GET请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。
* GET请求传输大小有限制，大小在2KB。
* GET相对安全性较差，会被浏览器主动缓存。
* GET产生一个TCP数据包，head和data一起发送。
* GET浏览器回退无害。

### POST

* POST请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。
* POST请求，理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。
* POST相对Get更安全，因为参数不会保存浏览器立式或者是web服务器日志中。
* POST产生两个TCP数据包，header先发送，服务器响应100ms然后继续，发送data，服务器200然后返回数据。
* POST浏览器回退重新请求。

## 输入一段url后发生了什么
网络阶段：构建请求行、查询强缓存、DNS解析、建立TCP连接、发送HTTP请求、响应请求、断开TCP连接
解析阶段：解析html、构建dom树、计算样式、生成布局树
渲染阶段：生成图层树、生成绘制列表、生成图块、优先选择视口附近的图块生成位图数据、展示内容

查询强缓存：cache-control，有缓存则调用缓存
1. DNS解析
查询浏览器缓存，是否有缓存的ip -> 查找操作系统缓存，本地的host文件 -> 查找本地dns缓存 -> 直接到根域名服务器上进行查询（根->顶级->权威)
客户端和本地dns服务器之间是递归查询，dns服务器之间是迭代查询

2. 建立tcp连接
3. 发送请求
4. 响应请求
5. 断开TCP连接
6. 解析和渲染

* 将HTML内容构建成DOM树；所有的节点都会进行构建，比如diaplay为none的，还有link，html节点等
* 将CSS内容构建成CSSOM树；不包含link，html等节点，但是会包含display为none的节点，来源分为style标签，外部link引入的样式文件，内联样式
* 将DOM 树和 CSSOM 树合成渲染树；为每个节点找到对应的样式，渲染树就不包含display为none的标签了
* 根据渲染树进行页面元素的布局；计算得出每个节点的位置和大小，得到布局树
* 对渲染树进行分层操作，并生成分层树；
* 为每个图层生成绘制列表，并提交到合成线程；
* 合成线程将图层分成不同的图块，将图块转化为位图；

很多情况下，图层可能很大，比如掘金的一篇长文，需要滚动很久才能到底，但是用户只能看到视口的内容，所以没必要把整个图层都绘制出来。因此，合成线程会将图层划分为图块。合成线程会优先将视口附近的图块生成位图。实际生成位图的操作是在光栅化阶段来执行的，所谓的光栅化就是按照绘制列表中的指令生成图片。
* 合成线程给浏览器进程发送绘制图块指令；
* 浏览器进程会生成页面，并显示在屏幕上。

https://juejin.cn/post/7018358245785862151#heading-1

## 重排和重绘
重排是重新计算页面的布局，影响了dom树中几何尺寸的变化。
重绘是指样式发生了变化，不需要重新计算几何属性
